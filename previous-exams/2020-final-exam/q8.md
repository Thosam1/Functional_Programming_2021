# Setup

You can use the following commands to make a fresh clone of your repository:

```
git clone -b q8 git@gitlab.epfl.ch:lamp/students-repositories-fall-2021/cs210-GASPAR.git cs210-q8
cd cs210-q8
```

You can always refer to:
  * [the example guide](https://gitlab.epfl.ch/lamp/cs210/blob/master/labs/example-lab.md) on the development workflow.
  * [this guide](https://gitlab.epfl.ch/lamp/cs210/blob/master/labs/grading-and-submission.md) for details on the submission system.
  * [The documentation of the Scala standard library](https://www.scala-lang.org/files/archive/api/2.13.3)
  * [The documentation of the Java standard
    library](https://docs.oracle.com/en/java/javase/15/docs/api/index.html)

**If you have issues with the IDE, try [reimporting the build](https://gitlab.epfl.ch/lamp/cs210/-/blob/master/labs/example-lab.md#ide-features-like-type-on-hover-or-go-to-definition-do-not-work), if you still have problems, use `compile` in sbt instead.**

# Be functional!

This course is about **functional** programming, therefore you're not allowed to use the following
constructs in this assignment:
- `var`
- `while`
- `return`
- Any class in the `scala.collection.mutable` package

# Exercise

You are given the method `fImperative`, which from a given list of integers, which represents heights of people standing in a bank queue, generates a list of the same size, such that the value of each element is the number of people visible to the corresponding person in the input list. A person is considered visible to another person if they are in front of them in the queue, and there is no taller (or equally tall) person in between. You can assume that all the elements of the input list are natural numbers.

For example, for the given input list: `(182, 160, 180, 178)` the output list should be `(0, 1, 2, 2)`.

```scala
  def fImperative(nums: List[Int]): List[Int] = {
    var i = 0
    var j = 0
    var res: List[Int] = List()

    while (i < nums.size) {
      var max = -1
      var cnt = 0
      j = i - 1
      while (j >= 0) {
        if(nums(j) > max) {
          cnt = cnt + 1
          max = nums(j)
        }
        j = j - 1
      }
      res = cnt :: res
      i = i + 1
    }
    res.reverse
  }
```

This solution uses var-s and while loops so it is not in the spirit of functional programming. Your task is to write a new implementation of this method in a purely functional way, using pattern matching and a limited set of existing list methods given in the appendix. Your solution should produce the same result as the given imperative method, but without imperative constructs such as var and while. You may define and implement additional methods. Correct solutions will be given a full score even if they are not tail-recursive.

In this exercise you are only allowed to use existing list methods which are listed in the appendix. 

`def f(nums: List[Int]): List[Int] = ???`

# Appendix

Here are the methods that you are allowed to use on `List[A]`:

`xs.head: A`: returns the first element of the list. Throws an exception if the list is empty.

`xs.tail: List[A]`: returns the list `xs` without its first element. Throws an exception if the list is empty.

`xs.isEmpty: Boolean`: returns `true` if the list does not contain any elements, `false` otherwise.

`x :: (xs: List[A]): List[A]`: prepends the element `x` to the left of `xs`, returning a `List[A]`.

`xs.reverse: List[A]`: reverses the elements of the list `xs`.
